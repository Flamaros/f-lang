// This file is generated by f-asm_nasm_db_to_code program

#pragma once

#include <fstd/language/types.hpp>

namespace f::ASM
{
    enum class Instruction : uint16_t
    {
        UNKNOWN,

        AAA,
        AAD,
        AAM,
        AAS,
        ADC,
        ADD,
        AND,
        ARPL,
        BOUND,
        BSF,
        BSR,
        BT,
        BTC,
        BTR,
        BTS,
        CALL,
        // Call/jmp near imm/reg/mem is always 64-bit in long mode.
        CBW,
        CDQ,
        CDQE,
        CLC,
        CLD,
        CLI,
        CLTS,
        CMC,
        CMP,
        CMPSB,
        CMPSD,
        CMPSQ,
        CMPSW,
        CMPXCHG486,
        CMPXCHG16B,
        CQO,
        CWD,
        CWDE,
        DAA,
        DAS,
        DEC,
        DIV,
        ENTER,
        F2XM1,
        FABS,
        FADD,
        FADDP,
        FBLD,
        FBSTP,
        FCHS,
        FCLEX,
        FCOM,
        FCOMP,
        FCOMPP,
        FCOS,
        FDECSTP,
        FDISI,
        FDIV,
        FDIVP,
        FDIVR,
        FDIVRP,
        FENI,
        FFREE,
        FFREEP,
        FIADD,
        FICOM,
        FICOMP,
        FIDIV,
        FIDIVR,
        FILD,
        FIMUL,
        FINCSTP,
        FINIT,
        FIST,
        FISTP,
        FISUB,
        FISUBR,
        FLD,
        FLD1,
        FLDCW,
        FLDENV,
        FLDL2E,
        FLDL2T,
        FLDLG2,
        FLDLN2,
        FLDPI,
        FLDZ,
        FMUL,
        FMULP,
        FNCLEX,
        FNDISI,
        FNENI,
        FNINIT,
        FNOP,
        FNSAVE,
        FNSTCW,
        FNSTENV,
        FNSTSW,
        FPATAN,
        FPREM,
        FPREM1,
        FPTAN,
        FRNDINT,
        FRSTOR,
        FSAVE,
        FSCALE,
        FSETPM,
        FSIN,
        FSINCOS,
        FSQRT,
        FST,
        FSTCW,
        FSTENV,
        FSTP,
        FSTSW,
        FSUB,
        FSUBP,
        FSUBR,
        FSUBRP,
        FTST,
        FUCOM,
        FUCOMP,
        FUCOMPP,
        FXAM,
        FXCH,
        FXTRACT,
        FYL2X,
        FYL2XP1,
        HLT,
        IBTS,
        ICEBP,
        IDIV,
        IMUL,
        IN,
        INC,
        INSB,
        INSD,
        INSW,
        INT,
        INT01,
        INT1,
        INT03,
        INT3,
        INTO,
        INVD,
        INVLPG,
        IRET,
        IRETD,
        IRETQ,
        IRETW,
        JCXZ,
        JECXZ,
        JRCXZ,
        JMP,
        // Call/jmp near imm/reg/mem is always 64-bit in long mode.
        LAHF,
        LAR,
        LDS,
        LEA,
        LEAVE,
        LES,
        LFENCE,
        LFS,
        LGDT,
        LGS,
        LIDT,
        LLDT,
        LMSW,
        LOADALL,
        LOADALL286,
        LODSB,
        LODSD,
        LODSQ,
        LODSW,
        LOOP,
        LOOPE,
        LOOPNE,
        LOOPNZ,
        LOOPZ,
        LSL,
        LSS,
        LTR,
        MFENCE,
        MOV,
        MOVSB,
        MOVSD,
        MOVSQ,
        MOVSW,
        MOVSX,
        MOVSXD,
        MOVSX,
        MOVZX,
        MUL,
        NEG,
        NOP,
        NOT,
        OR,
        OUT,
        OUTSB,
        OUTSD,
        OUTSW,
        PAUSE,
        POP,
        POPA,
        POPAD,
        POPAW,
        POPF,
        POPFD,
        POPFQ,
        POPFW,
        PUSH,
        PUSHA,
        PUSHAD,
        PUSHAW,
        PUSHF,
        PUSHFD,
        PUSHFQ,
        PUSHFW,
        RCL,
        RCR,
        RET,
        RETF,
        RETN,
        RETW,
        RETFW,
        RETNW,
        RETD,
        RETFD,
        RETND,
        RETQ,
        RETFQ,
        RETNQ,
        ROL,
        ROR,
        RSDC,
        RSLDT,
        RSTS,
        SAHF,
        SAL,
        SALC,
        SAR,
        SBB,
        SCASB,
        SCASD,
        SCASQ,
        SCASW,
        SFENCE,
        SGDT,
        SHL,
        SHLD,
        SHR,
        SHRD,
        SIDT,
        SLDT,
        SKINIT,
        SMI,
        // Older Cyrix chips had this; they had to move due to conflict with MMX
        SMINTOLD,
        SMSW,
        STC,
        STD,
        STI,
        STOSB,
        STOSD,
        STOSQ,
        STOSW,
        STR,
        SUB,
        SVDC,
        SVLDT,
        SVTS,
        SWAPGS,
        TEST,
        UD0,
        UD1,
        UD2B,
        UD2,
        UD2A,
        UMOV,
        VERR,
        VERW,
        // fix missing opcode from source https://www.felixcloutier.com/x86/wait:fwait
        FWAIT,
        WBINVD,
        XADD,
        XBTS,
        // This must be NOLONG since opcode 90 is NOP, and in 64-bit mode
        // "xchg eax,eax" is *not* a NOP.
        XCHG,
        XLATB,
        XLAT,
        XOR,
        // CMPPS/CMPSS must come after the specific ops; that way the disassembler will find the
        // specific ops first and only disassemble illegal ones as cmpps/cmpss.
        FXRSTOR64,
        FXSAVE64,
        // Introduced in late Penryn ... we really need to clean up the handling
        // of CPU feature bits.
        // These instructions are not SSE-specific; they are
        // and work even if CR4.OSFXFR == 0
        // PINSRW is documented as using a reg32, but it's really using only 16 bit
        // -- accept either, but be truthful in disassembly
        // CLFLUSH needs its own feature flag implemented one day
        // CMPPD/CMPSD must come after the specific ops; that way the disassembler will find the
        // specific ops first and only disassemble illegal ones as cmppd/cmpsd.
        PEXTRQ,
        PINSRQ,
        // Is NEHALEM right here?
        // Intel VAES instructions
        // Intel VAES + AVX512VL instructions
        // Intel VAES + AVX512F instructions
        // Specific aliases first, then the generic version, to keep the disassembler happy...
        // Specific aliases first, then the generic version, to keep the disassembler happy...
        // Specific aliases first, then the generic version, to keep the disassembler happy...
        // Specific aliases first, then the generic version, to keep the disassembler happy...
        // These are officially documented as VMOVDQA, but VMOVQQA seems more logical to me...
        // These are officially documented as VMOVDQU, but VMOVQQU seems more logical to me...
        // Officially VMOVNTDQ, but VMOVNTQQ seems more logical to me...
        // Intel VPCLMULQDQ instructions
        // Intel VPCLMULQDQ + AVX512VL instructions
        // Intel VPCLMULQDQ + AVX512F instructions
        //
        // Per AVX spec revision 7, document 319433-007
        // Per AVX spec revision 13, document 319433-013
        // Per AVX spec revision 14, document 319433-014
        //
        // based on pub number 43724 revision 3.04 date August 2009
        //
        // updated to match draft from AMD developer (patch has been
        // sent to binutils
        // 2010-03-22 Quentin Neill <quentin.neill@amd.com>
        //        Sebastian Pop  <sebastian.pop@amd.com>
        //
        //
        // based on pub number 43479 revision 3.04 dated November 2009
        //
        //
        // fixed: spec mention imm[7:4] though it should be /is4 even in spec
        //
        // fixed: spec mention only 3 operands in mnemonics
        //
        // fixed: spec point wrong VPCOMB in mnemonic
        //
        // fixed: spec has ymmreg for l0
        //
        // fixed: spec has VPHADDUBWD
        //
        // fixed: opcode db
        //
        // fixed: spec has ymmreg for l0
        //
        // fixed: spec has d7 opcode
        //
        // fixed: spec has 97,9f opcodes here
        //
        // fixed: spec point xmmreg instead of reg/mem
        //
        // fixed: spec error /r is needed
        //
        // fixed: spec error /r is needed
        //
        // fixed: spec has ymmreg for l0
        //
        // based on pub number 319433-011 dated July 2011
        //
        //
        // based on pub number 319433-011 dated July 2011
        //
        // MJC PUBLIC END
        RDPKRU,
        WRPKRU,
        // This one was killed before it saw the light of day
        // AMD Zen v1
        INCSSPQ,
        RDSSPQ,
        WRUSSQ,
        WRSSQ,
        // These should be last in the file

		COUNT,
    };

    enum class Register : uint8_t // @TODO Can we have more than 256 registers
    {
        UNKNOWN,


		COUNT,
    };

}
