#include <filesystem>
#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <iterator>
#include <regex>
#include <vector>
#include <algorithm>

#include <tracy/Tracy.hpp>

using namespace std;

enum class Instruction_Kind_State
{
	UNKNOWN,
	SPECIAL_INSTRUCTIONS,
	CONVENTIONAL_INSTRUCTIONS
};

std::vector<std::string> split(const std::string& s, char delim)
{
	std::vector<std::string> result;
	std::stringstream ss(s);
	std::string item;

	while (getline(ss, item, delim)) {
		result.push_back(item);
	}

	return result;
}

static vector<string> x64_instruction_sets = {
	"186",
	"286",
	"386",
	"486",
	"8086",
	"X64",

	// @TODO (Need to support up to 4 operands)
/*
	"3DNOW",
	"MMX",
	"SSE",
	"SSE2",
	"SSE3",
//	"SSE4A",	// AMD only?
	"SSE41",
	"SSE42",
	"SSE5",
	"AVX",
	"AVX2",
	"AVX512",
*/
};

int main(int ac, char** av)
{
#if defined(TRACY_ENABLE)
	tracy::SetThreadName("Main thread");
#endif
	FrameMark;

	filesystem::create_directories("./sources/ASM/generated");

	ofstream	asm_x64_cpp_file;
	ofstream	asm_x64_hpp_file;

	asm_x64_cpp_file.open("./sources/ASM/generated/ASM_x64.cpp", ios::trunc | ios::binary);
	asm_x64_hpp_file.open("./sources/ASM/generated/ASM_x64.hpp", ios::trunc | ios::binary);

	asm_x64_cpp_file <<
R"CODE(// This file is generated by f-asm_nasm_db_to_code program

#include "ASM_x64.hpp"

#include "../ASM.hpp"

namespace f::ASM
{
)CODE";

	asm_x64_hpp_file <<
R"CODE(// This file is generated by f-asm_nasm_db_to_code program

#pragma once

#include <fstd/language/types.hpp>

namespace f::ASM
{
)CODE";

	stringstream x64_cpp_instruction_desc_table_indices;
	stringstream x64_cpp_instruction_desc_table;
	stringstream x64_cpp_register_desc_table;

	x64_cpp_instruction_desc_table_indices <<
R"CODE(    size_t g_instruction_desc_table_indices[(size_t)Instruction::COUNT + 1] = {
        0,	// UNKNOWN
)CODE";

	x64_cpp_instruction_desc_table <<
R"CODE(    Instruction_Desc g_instruction_desc_table[] = {
        // UNKNOWN

)CODE";

	x64_cpp_register_desc_table <<
R"CODE(    Register_Desc	g_register_desc_table[(size_t)Register::COUNT] = {
        {Operand::Size::NONE, 0},	// UNKNOWN,

)CODE";

	stringstream x64_hpp_instruction_enum;
	stringstream x64_hpp_register_enum;

	x64_hpp_instruction_enum <<
R"CODE(    enum class Instruction : uint16_t
    {
        UNKNOWN,

)CODE";

	x64_hpp_register_enum <<
R"CODE(    enum class Register : uint8_t // @TODO Can we have more than 256 registers
    {
        UNKNOWN,

)CODE";

	string		read_line;
	ifstream	insns_dat_file("./data/insns.dat");
	if (insns_dat_file.is_open())
	{
		regex	instruction_desc_regex(R"REG((\w+)\s+([\w,]+)\s+(\[[\w\s\/\-:,]+\])\s+([\w,]+))REG");
		smatch	instruction_desc_match_result;
		regex	encoding_rules_regex(R"REG(([\-rmi]{0,4}):?\s+(\w+)\s+(\w+)\s+([\da-f]{2})s+(\/[\dr])?\s+([\w,]+))REG");
		smatch	encoding_rules_match_result;

		string					previous_instruction_name;
		size_t					x64_current_instruction_index = 0;
		Instruction_Kind_State	instruction_state = Instruction_Kind_State::UNKNOWN;
		while (getline(insns_dat_file, read_line))
		{
			if (read_line.starts_with(";;")) { // Verbose comment
				continue;
			}

			if (read_line.starts_with(";# Special instructions (pseudo-ops)")) { // Special instructions delimiter comment
				instruction_state = Instruction_Kind_State::SPECIAL_INSTRUCTIONS;
				continue;
			}
			else if (read_line.starts_with(";# Conventional instructions")) { // Conventional instructions delimiter comment
				instruction_state = Instruction_Kind_State::CONVENTIONAL_INSTRUCTIONS;
				continue;
			}

			if (instruction_state != Instruction_Kind_State::CONVENTIONAL_INSTRUCTIONS) {
				continue;
			}

			if (read_line.starts_with(";#")) { // Special comment
				// @TODO handle those particular instruction set types (AVX2, vendor specific, SSE5,...)

				//read_line.replace(0, 2, "//");
				//x64_cpp_instruction_desc_table << read_line << endl;
				continue;
			}
			if (read_line.starts_with(';')) { // Normal comment
				read_line.replace(0, 1, "//");
				x64_cpp_instruction_desc_table << "        " << read_line << endl;
				x64_hpp_instruction_enum << "        " << read_line << endl;
				continue;
			}

			if (regex_match(read_line, instruction_desc_match_result, instruction_desc_regex)) {
				sub_match instruction = instruction_desc_match_result[1];
				sub_match operand_types = instruction_desc_match_result[2];
				sub_match encoding_rules = instruction_desc_match_result[3];
				sub_match architectures_flags = instruction_desc_match_result[4];

				bool	is_x64_supported = false;

				vector<string>	architectures_flags_array = split(architectures_flags, ',');
				for (const string& architecture_or_flag : architectures_flags_array) {
					if (!is_x64_supported && find(x64_instruction_sets.begin(), x64_instruction_sets.end(), architecture_or_flag) != x64_instruction_sets.end()) {
							is_x64_supported = true;
					}
				}

				// @TODO skip instruction not supported by the targetted architecture (x64)
				// @TODO future when multiple architectures are supported:
				//   - create a bool by architecture to tell if the instruction is supported by the architecture
				//   - put if on the bool to write in the streams of architectures

				if (instruction != previous_instruction_name) {
					if (is_x64_supported) {
						x64_cpp_instruction_desc_table_indices << "        "
							<< x64_current_instruction_index << "," << "\t// " << instruction << endl;

						x64_hpp_instruction_enum << "        "
							<< instruction << "," << endl;
					}
				}

				if (is_x64_supported) {


					x64_cpp_instruction_desc_table << "        "
						<< instruction << " " << operand_types << endl;
					x64_current_instruction_index++;
				}

				previous_instruction_name = instruction;
			}



		}
	}

	x64_cpp_instruction_desc_table_indices << "    };" << endl << endl;
	x64_cpp_instruction_desc_table << "    };" << endl << endl;
	x64_cpp_register_desc_table << "    };" << endl << endl;

	asm_x64_cpp_file << x64_cpp_instruction_desc_table_indices.str() << endl;
	asm_x64_cpp_file << x64_cpp_instruction_desc_table.str() << endl;
	asm_x64_cpp_file << x64_cpp_register_desc_table.str() << endl;
	asm_x64_cpp_file << "}" << endl;

	x64_hpp_instruction_enum <<
R"CODE(
		COUNT,
    };
)CODE";

	x64_hpp_register_enum <<
R"CODE(
		COUNT,
    };
)CODE";

	asm_x64_hpp_file << x64_hpp_instruction_enum.str() << endl;
	asm_x64_hpp_file << x64_hpp_register_enum.str() << endl;
	asm_x64_hpp_file << "}" << endl;

	FrameMark;
	return 0;
}
